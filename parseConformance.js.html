<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: parseConformance.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: parseConformance.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @typedef ParseStructureDefinitionResponse
 * @property {string} _type
 * @property {ParseStructureDefinitionResponseProperty[]} _properties
 */

/**
 * @typedef ParseStructureDefinitionResponseProperty
 * @property {string} _name
 * @property {string} [_valueSet]
 * @property {string} [_valueSetStrength]
 * @property {ParseStructureDefinitionResponseProperty[]} _properties
 */

/**
 * @typedef ParseValueSetResponse
 * @property {ParseValueSetResponseSystem[]} systems
 */

/**
 * @typedef ParseValueSetResponseSystem
 * @property {ParseValueSetRepsonseSystemCode[]} codes
 * @property {string} uri
 */

/**
 * @typedef ParseValueSetResponseSystemCode
 * @property {string} code
 * @property {string} display
 */

var _ = require('underscore');

/**
 * Class responsible for parsing StructureDefinition and ValueSet resources into bare-minimum information
 * needed for serialization and validation.
 * @param {boolean} loadCached
 * @param {StructureDefinition[]} [coreStructureDefinitions]
 * @param {Bundle} [coreValueSetBundle]
 * @constructor
 */
function ParseConformance(loadCached, coreStructureDefinitions, coreValueSetBundle) {
    /**
     * @type {ParseStructureDefinitionResponse[]}
     */
    this.parsedStructureDefinitions = loadCached ? require('./profiles/types.json') : {};

    /**
     * @type {ParseValueSetResponse[]}
     */
    this.parsedValueSets = loadCached ? require('./profiles/valuesets.json') : {};

    /**
     * @type {StructureDefinition[]}
     * @private
     */
    this._coreStructureDefinitions = coreStructureDefinitions;

    /**
     * @type {Bundle}
     * @private
     */
    this._coreValueSetBundle = coreValueSetBundle;
}

/**
 * Parses all core resources specified as part of the constructor.
 * Only parses value sets referenced by core structure definitions that are in the core value sets
 */
ParseConformance.prototype.parseCoreResources = function() {
    if (!this._coreStructureDefinitions) {
        throw 'Core structure definitions not specified';
    }

    for (var i in this._coreStructureDefinitions) {
        this.parseStructureDefinition(this._coreStructureDefinitions[i]);
    }
}

/**
 * Parses a StructureDefinition resource, reading only properties necessary for the FHIR.js module to perform its functions.
 * structureDefinition must have a unique id, or it will overwrite other parsed structure definitions stored in memory
 * @param {StructureDefinition} structureDefinition The StructureDefinition to parse and load into memory
 * @returns {ParseStructureDefinitionResponseProperty}
 */
ParseConformance.prototype.parseStructureDefinition = function(structureDefinition) {
    var self = this;

    var parsedStructureDefinition = {
        _type: 'Resource',
        _properties: []
    };
    this.parsedStructureDefinitions[structureDefinition.id] = parsedStructureDefinition;         // TODO: Not sure this works for profiles

    if (structureDefinition.snapshot &amp;&amp; structureDefinition.snapshot.element) {
        for (var x in structureDefinition.snapshot.element) {
            var element = structureDefinition.snapshot.element[x];
            var elementId = structureDefinition.snapshot.element[x].id;
            elementId = elementId.substring(structureDefinition.id.length + 1);

            if (!element.max) {
                throw 'Expected all base resource elements to have a max value';
            }

            if (!elementId || elementId.indexOf('.') > 0 || !element.type) {
                continue;
            }

            if (element.type.length === 1) {
                var newProperty = {
                    _name: elementId,
                    _type: element.type[0].code,
                    _multiple: element.max !== '1',
                    _required: element.min === 1
                };
                parsedStructureDefinition._properties.push(newProperty);

                self.populateValueSet(element, newProperty);

                if (element.type[0].code == 'BackboneElement') {
                    newProperty._properties = [];
                    self.populateBackboneElement(parsedStructureDefinition, structureDefinition.snapshot.element[x].id, structureDefinition);
                }
            } else if (elementId.endsWith('[x]')) {
                elementId = elementId.substring(0, elementId.length - 3);
                for (var y in element.type) {
                    var choiceType = element.type[y].code;
                    choiceType = choiceType.substring(0, 1).toUpperCase() + choiceType.substring(1);
                    var choiceElementId = elementId + choiceType;
                    var newProperty = {
                        _name: choiceElementId,
                        _choice: elementId,
                        _type: element.type[y].code,
                        _multiple: element.max !== '1',
                        _required: element.min === 1
                    };

                    self.populateValueSet(element, newProperty);

                    parsedStructureDefinition._properties.push(newProperty);
                }
            } else {
                var isReference = true;
                for (var y in element.type) {
                    if (element.type[y].code !== 'Reference') {
                        isReference = false;
                        break;
                    }
                }

                if (isReference) {
                    parsedStructureDefinition._properties.push({
                        _name: elementId,
                        _type: 'Reference',
                        _multiple: element.max !== '1'
                    });
                } else {
                    console.log(elementId);
                }
            }
        }
    }

    return parsedStructureDefinition;
}

/**
 * Parses the ValueSet resource. Parses only bare-minimum information needed for validation against value sets.
 * Currently only supports parsing 'compose'
 * @param {ValueSet} valueSet The ValueSet resource to parse and load into memory
 * @returns {ParseValueSetResponse}
 */
ParseConformance.prototype.parseValueSet = function(valueSet) {
    var self = this;

    if (valueSet.compose) {
        var newValueSet = {
            systems: []
        };

        for (var i = 0; i &lt; valueSet.compose.include.length; i++) {
            var include = valueSet.compose.include[i];
            var newSystem = {
                uri: include.system,
                codes: []
            };

            var nextCodes = null;

            if (!include.concept) {
                if (!this._coreValueSetBundle) {
                    return;
                }

                // Add all codes from the code system
                var foundCodeSystem = _.find(this._coreValueSetBundle.entry, function(entry) {
                    return entry.resource.url === include.system
                });

                // Couldn't find the code system, won't include it in validation
                if (!foundCodeSystem) {
                    return;
                }

                foundCodeSystem = foundCodeSystem.resource;

                nextCodes = _.map(foundCodeSystem.concept, function(concept) {
                    return {
                        code: concept.code,
                        display: concept.display
                    };
                });
            } else {
                nextCodes = _.map(include.concept, function(concept) {
                    return {
                        code: concept.code,
                        display: concept.display
                    };
                });
            }

            newSystem.codes = newSystem.codes.concat(nextCodes);
            newValueSet.systems.push(newSystem);
        }

        self.parsedValueSets[valueSet.url] = newValueSet;
        return newValueSet;
    }
}

/**
 * This method is called to ensure that a value set (by its url) is loaded from the core spec
 * @param {string} valueSetUrl The url of the value set
 * @returns {boolean} Returns true if the value set was found/loaded, otherwise false
 * @private
 */
ParseConformance.prototype.ensureValueSetLoaded = function(valueSetUrl) {
    var self = this;

    if (this.parsedValueSets[valueSetUrl]) {
        return true;
    }

    if (!this._coreValueSetBundle) {
        return false;
    }

    var foundValueSetEntry = _.find(this._coreValueSetBundle.entry, function(entry) {
        return entry.fullUrl === valueSetUrl;
    });

    if (!foundValueSetEntry) {
        return false;
    }

    var foundValueSet = foundValueSetEntry.resource;

    if (this.parseValueSet(foundValueSet)) {
        return true;
    }

    return false;
}

/**
 * @param {ElementDefinition} element
 * @param {ParseStructureDefinitionResponseProperty} property
 * @private
 */
ParseConformance.prototype.populateValueSet = function(element, property) {
    var self = this;
    if (element.binding &amp;&amp; element.binding.valueSetReference) {
        property._valueSet = element.binding.valueSetReference.reference;

        if (element.binding.strength) {
            property._valueSetStrength = element.binding.strength;
        }

        self.ensureValueSetLoaded(element.binding.valueSetReference.reference);
    }
}

/**
 * @param {string} resourceType
 * @param {string} parentElementId
 * @param {StructureDefinition} profile
 * @private
 */
ParseConformance.prototype.populateBackboneElement = function(resourceType, parentElementId, profile) {
    var self = this;
    for (var y in profile.snapshot.element) {
        var backboneElement = profile.snapshot.element[y];
        var backboneElementId = backboneElement.id;
        if (!backboneElementId.startsWith(parentElementId + '.') || backboneElementId.split('.').length !== parentElementId.split('.').length + 1) {
            continue;
        }

        backboneElementId = backboneElementId.substring(profile.id.length + 1);
        var parentElementIdSplit = parentElementId.substring(profile.id.length + 1).split('.');
        var parentBackboneElement = null;

        for (var j = 0; j &lt; parentElementIdSplit.length; j++) {
            parentBackboneElement = _.find(!parentBackboneElement ? resourceType._properties : parentBackboneElement._properties, function(property) {
                return property._name == parentElementIdSplit[j];
            });

            if (!parentBackboneElement) {
                throw 'Parent backbone element not found';
            }
        }

        if (parentBackboneElement) {
            if (!backboneElement.type) {
                var type = 'string';

                if (backboneElement.contentReference) {
                    type = backboneElement.contentReference;
                }

                parentBackboneElement._properties.push({
                    _name: backboneElementId.substring(backboneElementId.lastIndexOf('.') + 1),
                    _type: type,
                    _multiple: backboneElement.max !== '1',
                    _required: backboneElement.min === 1
                });
            } else if (backboneElement.type.length == 1) {
                var newProperty = {
                    _name: backboneElementId.substring(backboneElementId.lastIndexOf('.') + 1),
                    _type: backboneElement.type[0].code,
                    _multiple: backboneElement.max !== '1',
                    _required: backboneElement.min === 1,
                    _properties: []
                };
                parentBackboneElement._properties.push(newProperty);

                self.populateValueSet(backboneElement, newProperty);

                if (backboneElement.type[0].code == 'BackboneElement') {
                    self.populateBackboneElement(resourceType, profile.snapshot.element[y].id, profile);
                }
            } else if (backboneElement.id.endsWith('[x]')) {
                var nextElementId = backboneElement.id.substring(backboneElement.id.lastIndexOf('.') + 1, backboneElement.id.length - 3);
                for (var y in backboneElement.type) {
                    var choiceType = backboneElement.type[y].code;
                    choiceType = choiceType.substring(0, 1).toUpperCase() + choiceType.substring(1);
                    var choiceElementId = backboneElement.id.substring(backboneElement.id.lastIndexOf('.') + 1, backboneElement.id.length - 3) + choiceType;
                    var newProperty = {
                        _name: choiceElementId,
                        _choice: backboneElement.id.substring(backboneElement.id.lastIndexOf('.') + 1),
                        _type: backboneElement.type[y].code,
                        _multiple: backboneElement.max !== '1',
                        _required: backboneElement.min === 1
                    };
                    parentBackboneElement._properties.push(newProperty);

                    self.populateValueSet(backboneElement, newProperty);
                }
            } else {
                var isReference = true;
                for (var z in backboneElement.type) {
                    if (backboneElement.type[z].code !== 'Reference') {
                        isReference = false;
                        break;
                    }
                }

                if (!isReference) {
                    throw 'Did not find a reference... not sure what to do';
                }

                var newProperty = {
                    _name: backboneElementId.substring(backboneElementId.lastIndexOf('.') + 1),
                    _type: 'Reference',
                    _multiple: backboneElement.max !== '1',
                    _required: backboneElement.min === 1
                };
                parentBackboneElement._properties.push(newProperty);

                self.populateValueSet(backboneElement, newProperty);
            }
        } else {
            throw 'Unexpected backbone parent element id';
        }
    }
}

module.exports = ParseConformance;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ConvertToJS.html">ConvertToJS</a></li><li><a href="ConvertToXML.html">ConvertToXML</a></li><li><a href="Fhir.html">Fhir</a></li><li><a href="ParseConformance.html">ParseConformance</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Jun 12 2018 15:58:58 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
